// game-resonance.js — Generated by GAME compiler v0.2.0
// Zero-dependency WebGPU component with WebGL2 fallback.
//   <script type="module" src="./game-resonance.js"></script>
//   <game-resonance></game-resonance>

const SHADER = `// Generated by GAME compiler v0.2.0
// https://github.com/runyourempire/game-engine

struct Uniforms {
    time: f32,
    audio_bass: f32,
    audio_mid: f32,
    audio_treble: f32,
    audio_energy: f32,
    audio_beat: f32,
    resolution: vec2f,
    mouse: vec2f,
    p_intensity: f32,
    p_freq: f32,
    p_clarity: f32,
    p_density: f32,
}

@group(0) @binding(0) var<uniform> u: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(@builtin(vertex_index) vi: u32) -> VertexOutput {
    var pos = array<vec2f, 4>(
        vec2f(-1.0, -1.0),
        vec2f( 1.0, -1.0),
        vec2f(-1.0,  1.0),
        vec2f( 1.0,  1.0),
    );
    var out: VertexOutput;
    out.position = vec4f(pos[vi], 0.0, 1.0);
    out.uv = pos[vi] * 0.5 + 0.5;
    return out;
}

// ── Built-in functions ──────────────────────────────────

fn apply_glow(d: f32, intensity: f32) -> f32 {
    return exp(-max(d, 0.0) * intensity * 8.0);
}

fn hash2(p: vec2f) -> f32 {
    var p3 = fract(vec3f(p.x, p.y, p.x) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash2v(p: vec2f) -> vec2f {
    var p3 = fract(vec3f(p.x, p.y, p.x) * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

fn noise2(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(hash2(i), hash2(i + vec2f(1.0, 0.0)), u.x),
        mix(hash2(i + vec2f(0.0, 1.0)), hash2(i + vec2f(1.0, 1.0)), u.x),
        u.y
    ) * 2.0 - 1.0;
}

fn fbm2(p: vec2f, octaves: i32, persistence: f32, lacunarity: f32) -> f32 {
    var value: f32 = 0.0;
    var amplitude: f32 = 1.0;
    var frequency: f32 = 1.0;
    var max_val: f32 = 0.0;
    for (var i: i32 = 0; i < octaves; i++) {
        value += noise2(p * frequency) * amplitude;
        max_val += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return value / max_val;
}

fn simplex2(p: vec2f) -> f32 {
    let K1: f32 = 0.366025404;
    let K2: f32 = 0.211324865;
    let s = (p.x + p.y) * K1;
    let i = floor(p + s);
    let a = p - i + (i.x + i.y) * K2;
    let o = select(vec2f(0.0, 1.0), vec2f(1.0, 0.0), a.x > a.y);
    let b = a - o + K2;
    let c = a - 1.0 + 2.0 * K2;
    var h = max(vec3f(0.5) - vec3f(dot(a, a), dot(b, b), dot(c, c)), vec3f(0.0));
    h = h * h * h * h;
    let ga = hash2v(i) * 2.0 - 1.0;
    let gb = hash2v(i + o) * 2.0 - 1.0;
    let gc = hash2v(i + 1.0) * 2.0 - 1.0;
    let n = h * vec3f(dot(ga, a), dot(gb, b), dot(gc, c));
    return dot(n, vec3f(70.0));
}

fn voronoi2(p: vec2f) -> f32 {
    let n = floor(p);
    let f = fract(p);
    var md: f32 = 8.0;
    for (var j: i32 = -1; j <= 1; j++) {
        for (var i: i32 = -1; i <= 1; i++) {
            let g = vec2f(f32(i), f32(j));
            let o = hash2v(n + g);
            let r = g + o - f;
            let d = dot(r, r);
            md = min(md, d);
        }
    }
    return sqrt(md);
}

fn curl2(p: vec2f, freq: f32, amp: f32) -> vec2f {
    let eps: f32 = 0.001;
    let n0 = simplex2(p * freq);
    let nx = simplex2((p + vec2f(eps, 0.0)) * freq);
    let ny = simplex2((p + vec2f(0.0, eps)) * freq);
    let dndx = (nx - n0) / eps;
    let dndy = (ny - n0) / eps;
    return vec2f(dndy, -dndx) * amp;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4f {
    let uv = input.uv * 2.0 - 1.0;
    let aspect = u.resolution.x / u.resolution.y;
    let time = fract(u.time / 120.0) * 120.0;

    let intensity = u.p_intensity;
    let freq = u.p_freq;
    let clarity = u.p_clarity;
    let density = u.p_density;

    var final_color = vec4f(0.0, 0.0, 0.0, 1.0);

    // ── Layer 0: fire ──
    {
        var p = vec2f(uv.x * aspect, uv.y);
        // stage 0: fbm(...)
        var sdf_result = fbm2((p * freq), i32(5.0), 0.5, 2.0);

        // stage 1: threshold(...)
        sdf_result = step(0.4, sdf_result);

        // stage 2: glow(...)
        let glow_result = apply_glow(sdf_result, 4.0);

        // stage 3: tint(...)
        var color_result = vec4f(vec3f(glow_result) * vec3f(0.8, 0.2, 0.05), 1.0);

        let lc = color_result.rgb;
        final_color = vec4f(final_color.rgb + lc * 1.000, 1.0);
    }

    // ── Layer 1: ice ──
    {
        var p = vec2f(uv.x * aspect, uv.y);
        // stage 0: voronoi(...)
        var sdf_result = voronoi2(p * (p * density));

        // stage 1: glow(...)
        let glow_result = apply_glow(sdf_result, 2.0);

        // stage 2: tint(...)
        var color_result = vec4f(vec3f(glow_result) * vec3f(0.85, 0.92, 1.0), 1.0);

        // stage 3: iridescent(...)
        { let iri_angle = atan2(p.y, p.x);
        let iri_r = length(p);
        let iri_phase = iri_angle * 3.0 + iri_r * 10.0 + time;
        let iri_shift = vec3f(
            sin(iri_phase) * 0.5 + 0.5,
            sin(iri_phase + 2.094) * 0.5 + 0.5,
            sin(iri_phase + 4.189) * 0.5 + 0.5
        );
        color_result = vec4f(mix(color_result.rgb, color_result.rgb * iri_shift, 0.3), 1.0); }

        let lc = color_result.rgb;
        final_color = vec4f(final_color.rgb + lc * 1.000, 1.0);
    }

    // ── Layer 2: smoke ──
    {
        var p = vec2f(uv.x * aspect, uv.y);
        // stage 0: curl_noise(...)
        let curl_offset = curl2((p * 2.0), 1.5, 1.0);
        var sdf_result = length(curl_offset) - 0.01;

        // stage 1: glow(...)
        let glow_result = apply_glow(sdf_result, 1.5);

        // stage 2: tint(...)
        var color_result = vec4f(vec3f(glow_result) * vec3f(0.45, 0.42, 0.40), 1.0);

        let lc = color_result.rgb;
        final_color = vec4f(final_color.rgb + lc * 0.500, 1.0);
    }

    return final_color;
}
`;
const GLSL_VS = `#version 300 es
precision highp float;

uniform float u_time;
uniform float u_audio_bass;
uniform float u_audio_mid;
uniform float u_audio_treble;
uniform float u_audio_energy;
uniform float u_audio_beat;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_p_intensity;
uniform float u_p_freq;
uniform float u_p_clarity;
uniform float u_p_density;

out vec2 v_uv;

void main() {
    vec2 pos[4] = vec2[4](
        vec2(-1.0, -1.0),
        vec2( 1.0, -1.0),
        vec2(-1.0,  1.0),
        vec2( 1.0,  1.0)
    );
    gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);
    v_uv = pos[gl_VertexID] * 0.5 + 0.5;
}
`;
const GLSL_FS = `#version 300 es
precision highp float;

uniform float u_time;
uniform float u_audio_bass;
uniform float u_audio_mid;
uniform float u_audio_treble;
uniform float u_audio_energy;
uniform float u_audio_beat;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_p_intensity;
uniform float u_p_freq;
uniform float u_p_clarity;
uniform float u_p_density;

in vec2 v_uv;
out vec4 fragColor;






// ── Built-in functions ──────────────────────────────────


float apply_glow(d: float, intensity: float){
    return exp(-max(d, 0.0) * intensity * 8.0);
}

float hash2(p: vec2){
    float p3 = fract(vec3(p.x, p.y, p.x) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec2 hash2v(p: vec2){
    float p3 = fract(vec3(p.x, p.y, p.x) * vec3(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

float noise2(p: vec2){
    float i = floor(p);
    float f = fract(p);
    float u = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(hash2(i), hash2(i + vec2(1.0, 0.0)), u.x),
        mix(hash2(i + vec2(0.0, 1.0)), hash2(i + vec2(1.0, 1.0)), u.x),
        u.y
    ) * 2.0 - 1.0;
}

float fbm2(p: vec2, octaves: i32, persistence: float, lacunarity: float){
    float value: float = 0.0;
    float amplitude: float = 1.0;
    float frequency: float = 1.0;
    float max_val: float = 0.0;
    for (int i = 0; i < octaves; i++) {
        value += noise2(p * frequency) * amplitude;
        max_val += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return value / max_val;
}

float simplex2(p: vec2){
    float K1: float = 0.366025404;
    float K2: float = 0.211324865;
    float s = (p.x + p.y) * K1;
    float i = floor(p + s);
    float a = p - i + (i.x + i.y) * K2;
    float o = (a.x > a.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0));
    float b = a - o + K2;
    float c = a - 1.0 + 2.0 * K2;
    float h = max(vec3(0.5) - vec3(dot(a, a), dot(b, b), dot(c, c)), vec3(0.0));
    h = h * h * h * h;
    float ga = hash2v(i) * 2.0 - 1.0;
    float gb = hash2v(i + o) * 2.0 - 1.0;
    float gc = hash2v(i + 1.0) * 2.0 - 1.0;
    float n = h * vec3(dot(ga, a), dot(gb, b), dot(gc, c));
    return dot(n, vec3(70.0));
}

float voronoi2(p: vec2){
    float n = floor(p);
    float f = fract(p);
    float md: float = 8.0;
    for (int j = -1; j <= 1; j++) {
        for (int i = -1; i <= 1; i++) {
            vec2 g = vec2(float(i), float(j));
            float o = hash2v(n + g);
            float r = g + o - f;
            float d = dot(r, r);
            md = min(md, d);
        }
    }
    return sqrt(md);
}

vec2 curl2(p: vec2, freq: float, amp: float){
    float eps: float = 0.001;
    float n0 = simplex2(p * freq);
    float nx = simplex2((p + vec2(eps, 0.0)) * freq);
    float ny = simplex2((p + vec2(0.0, eps)) * freq);
    float dndx = (nx - n0) / eps;
    float dndy = (ny - n0) / eps;
    return vec2(dndy, -dndx) * amp;
}

void fs_main(input: VertexOutput){
    float uv = v_uv * 2.0 - 1.0;
    float aspect = u_resolution.x / u_resolution.y;
    float time = fract(u_time / 120.0) * 120.0;

    float intensity = u_p_intensity;
    float freq = u_p_freq;
    float clarity = u_p_clarity;
    float density = u_p_density;

    vec4 final_color = vec4(0.0, 0.0, 0.0, 1.0);

    // ── Layer 0: fire ──
    {
        vec2 p = vec2(uv.x * aspect, uv.y);
        // stage 0: fbm(...)
        float sdf_result = fbm2((p * freq), int(5.0), 0.5, 2.0);

        // stage 1: threshold(...)
        sdf_result = step(0.4, sdf_result);

        // stage 2: glow(...)
        float glow_result = apply_glow(sdf_result, 4.0);

        // stage 3: tint(...)
        vec4 color_result = vec4(vec3(glow_result) * vec3(0.8, 0.2, 0.05), 1.0);

        vec3 lc = color_result.rgb;
        final_color = vec4(final_color.rgb + lc * 1.000, 1.0);
    }

    // ── Layer 1: ice ──
    {
        vec2 p = vec2(uv.x * aspect, uv.y);
        // stage 0: voronoi(...)
        float sdf_result = voronoi2(p * (p * density));

        // stage 1: glow(...)
        float glow_result = apply_glow(sdf_result, 2.0);

        // stage 2: tint(...)
        vec4 color_result = vec4(vec3(glow_result) * vec3(0.85, 0.92, 1.0), 1.0);

        // stage 3: iridescent(...)
        { float iri_angle = atan2(p.y, p.x);
        float iri_r = length(p);
        float iri_phase = iri_angle * 3.0 + iri_r * 10.0 + time;
        vec3 iri_shift = vec3(
            sin(iri_phase) * 0.5 + 0.5,
            sin(iri_phase + 2.094) * 0.5 + 0.5,
            sin(iri_phase + 4.189) * 0.5 + 0.5
        );
        color_result = vec4(mix(color_result.rgb, color_result.rgb * iri_shift, 0.3), 1.0); }

        vec3 lc = color_result.rgb;
        final_color = vec4(final_color.rgb + lc * 1.000, 1.0);
    }

    // ── Layer 2: smoke ──
    {
        vec2 p = vec2(uv.x * aspect, uv.y);
        // stage 0: curl_noise(...)
        float curl_offset = curl2((p * 2.0), 1.5, 1.0);
        float sdf_result = length(curl_offset) - 0.01;

        // stage 1: glow(...)
        float glow_result = apply_glow(sdf_result, 1.5);

        // stage 2: tint(...)
        vec4 color_result = vec4(vec3(glow_result) * vec3(0.45, 0.42, 0.40), 1.0);

        vec3 lc = color_result.rgb;
        final_color = vec4(final_color.rgb + lc * 0.500, 1.0);
    }

    return final_color;
}
`;

class GameResonance extends HTMLElement {
  static get observedAttributes() {
    return [];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._data = {  };
    this._device = null;
    this._ctx = null;
    this._pipeline = null;
    this._uniformBuffer = null;
    this._uniformData = null;
    this._bindGroup = null;
    this._animFrame = null;
    this._resizeObserver = null;
    this._startTime = 0;
    this._canvas = null;
    this._format = null;
    this._mouseX = 0.5;
    this._mouseY = 0.5;
    this._paramValues = new Float32Array(4);
  }


  attributeChangedCallback(name, _, newVal) {
    if (name in this._data) {
      this._data[name] = parseFloat(newVal) || 0;
    }
  }

  connectedCallback() {
    this._init();
  }

  disconnectedCallback() {
    if (this._animFrame) {
      cancelAnimationFrame(this._animFrame);
      this._animFrame = null;
    }
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    this._device = null;
    this._pipeline = null;
    this._uniformBuffer = null;
    this._ctx = null;
  }

  async _init() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; position: relative; background: #000; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .fallback { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #444; font: 11px/1 system-ui, sans-serif; text-align: center; }
      </style>
      <canvas></canvas>
    `;

    this._canvas = this.shadowRoot.querySelector('canvas');

    if (!navigator.gpu) {
      this._initWebGL2();
      return;
    }

    const adapter = await navigator.gpu.requestAdapter({
      powerPreference: 'high-performance',
    });
    if (!adapter) return;

    this._device = await adapter.requestDevice();
    this._device.lost.then((info) => {
      console.error('WebGPU device lost:', info.message);
    });

    this._ctx = this._canvas.getContext('webgpu');
    this._format = navigator.gpu.getPreferredCanvasFormat();

    this._resize();
    this._resizeObserver = new ResizeObserver(() => this._resize());
    this._resizeObserver.observe(this);

    const shaderModule = this._device.createShaderModule({ code: SHADER });

    const BUFFER_SIZE = 64;
    this._uniformBuffer = this._device.createBuffer({
      size: BUFFER_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const bindGroupLayout = this._device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: { type: 'uniform' },
      }],
    });

    this._bindGroup = this._device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{ binding: 0, resource: { buffer: this._uniformBuffer } }],
    });

    this._pipeline = this._device.createRenderPipeline({
      layout: this._device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout],
      }),
      vertex: {
        module: shaderModule,
        entryPoint: 'vs_main',
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fs_main',
        targets: [{ format: this._format }],
      },
      primitive: {
        topology: 'triangle-strip',
      },
    });

    this._uniformData = new Float32Array(Math.ceil(BUFFER_SIZE / 4));
    this._startTime = performance.now() / 1000;

    // Mouse tracking scoped to this element
    this.addEventListener('mousemove', (e) => {
      const rect = this.getBoundingClientRect();
      this._mouseX = (e.clientX - rect.left) / rect.width;
      this._mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    });

    this._frame();
  }

  _resize() {
    if (!this._device || !this._ctx || !this._format) return;
    const rect = this.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;
    const dpr = window.devicePixelRatio || 1;
    this._canvas.width = Math.floor(rect.width * dpr);
    this._canvas.height = Math.floor(rect.height * dpr);
    this._ctx.configure({
      device: this._device,
      format: this._format,
      alphaMode: 'opaque',
    });
  }

  _frame() {
    this._animFrame = requestAnimationFrame(() => this._frame());
    if (!this._device || !this._pipeline || !this._uniformBuffer) return;

    const now = performance.now() / 1000;
    const time = now - this._startTime;
    const mouseX = this._mouseX;
    const mouseY = this._mouseY;

    // Apply arc timeline (override param bases)
    if (!this._arcTimeline) {
      const ease = {
  linear: t => t,
  expo_in: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  expo_out: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  cubic_in_out: t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2,
  smooth: t => t * t * (3 - 2 * t),
  elastic: t => t === 0 || t === 1 ? t : -Math.pow(2, 10*t - 10) * Math.sin((t*10 - 10.75) * (2*Math.PI/3)),
  bounce: t => { const n=7.5625, d=2.75; if(t<1/d) return n*t*t; if(t<2/d) return n*(t-=1.5/d)*t+0.75; if(t<2.5/d) return n*(t-=2.25/d)*t+0.9375; return n*(t-=2.625/d)*t+0.984375; },
};
      this._arcEase = ease;
      this._arcTimeline = [
        { t: 0, name: 'still', transitions: [{ pi: 0, to: 0.1, anim: false, ease: 'linear', dur: 15 },{ pi: 2, to: 0.1, anim: false, ease: 'linear', dur: 15 },] },
        { t: 15, name: 'fire awakens', transitions: [{ pi: 0, to: 0.8, anim: true, ease: 'expo_out', dur: 10 },] },
        { t: 35, name: 'ice responds', transitions: [{ pi: 2, to: 0.9, anim: true, ease: 'cubic_in_out', dur: 8 },] },
      ];
      this._arcState = new Map();
    }
    for (let mi = 0; mi < this._arcTimeline.length; mi++) {
      const m = this._arcTimeline[mi];
      if (time < m.t) continue;
      for (const tr of m.transitions) {
        const key = `${mi}_${tr.pi}`;
        if (!tr.anim) {
          this._arcBaseOverrides = this._arcBaseOverrides || {};
          this._arcBaseOverrides[tr.pi] = tr.to;
          continue;
        }
        const elapsed = time - m.t;
        const progress = Math.min(elapsed / tr.dur, 1.0);
        if (!this._arcState.has(key)) {
          this._arcState.set(key, this._arcBaseOverrides?.[tr.pi] ?? 0);
        }
        const from = this._arcState.get(key);
        const easeFn = this._arcEase[tr.ease] || this._arcEase.linear;
        const t = easeFn(progress);
        this._arcBaseOverrides = this._arcBaseOverrides || {};
        this._arcBaseOverrides[tr.pi] = from + (tr.to - from) * t;
      }
    }


    // Update param values
    this._paramValues[0] = (this._arcBaseOverrides?.[0] ?? 0.5) + audioBass;
    this._paramValues[1] = (this._arcBaseOverrides?.[1] ?? 3) + 0;
    this._paramValues[2] = (this._arcBaseOverrides?.[2] ?? 0.8) + audioTreble;
    this._paramValues[3] = (this._arcBaseOverrides?.[3] ?? 3) + 0;

    // Write uniforms
    this._uniformData[0] = time;
    this._uniformData[1] = 0; // audio_bass (unused in component mode)
    this._uniformData[2] = 0; // audio_mid
    this._uniformData[3] = 0; // audio_treble
    this._uniformData[4] = 0; // audio_energy
    this._uniformData[5] = 0; // audio_beat
    this._uniformData[6] = this._canvas.width;
    this._uniformData[7] = this._canvas.height;
    this._uniformData[8] = mouseX;
    this._uniformData[9] = mouseY;

    for (let i = 0; i < 4; i++) {
      this._uniformData[10 + i] = this._paramValues[i];
    }

    this._device.queue.writeBuffer(this._uniformBuffer, 0, this._uniformData);

    const encoder = this._device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
      colorAttachments: [{
        view: this._ctx.getCurrentTexture().createView(),
        loadOp: 'clear',
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        storeOp: 'store',
      }],
    });
    pass.setPipeline(this._pipeline);
    pass.setBindGroup(0, this._bindGroup);
    pass.draw(4, 1, 0, 0);
    pass.end();
    this._device.queue.submit([encoder.finish()]);
  }

  // ── WebGL2 Fallback ──────────────────────────────────────
  _initWebGL2() {
    const gl = this._canvas.getContext('webgl2');
    if (!gl) {
      this._canvas.style.display = 'none';
      const fb = document.createElement('div');
      fb.className = 'fallback';
      fb.textContent = 'WebGPU and WebGL2 not available';
      this.shadowRoot.appendChild(fb);
      return;
    }

    this._gl = gl;
    this._glMode = true;

    // Compile shaders
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, GLSL_VS);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      console.error('GLSL vertex error:', gl.getShaderInfoLog(vs));
      return;
    }

    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, GLSL_FS);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      console.error('GLSL fragment error:', gl.getShaderInfoLog(fs));
      return;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error('GLSL link error:', gl.getProgramInfoLog(prog));
      return;
    }

    this._glProgram = prog;

    // Cache uniform locations
    this._glUniforms = {
      u_time: gl.getUniformLocation(prog, 'u_time'),
      u_audio_bass: gl.getUniformLocation(prog, 'u_audio_bass'),
      u_audio_mid: gl.getUniformLocation(prog, 'u_audio_mid'),
      u_audio_treble: gl.getUniformLocation(prog, 'u_audio_treble'),
      u_audio_energy: gl.getUniformLocation(prog, 'u_audio_energy'),
      u_audio_beat: gl.getUniformLocation(prog, 'u_audio_beat'),
      u_resolution: gl.getUniformLocation(prog, 'u_resolution'),
      u_mouse: gl.getUniformLocation(prog, 'u_mouse'),
    };

    // Cache dynamic param uniform locations
    this._glParamUniforms = [];
    for (let i = 0; i < 4; i++) {
      const name = 'u_p_' + ['placeholder'][0]; // Will be set per-param below
      this._glParamUniforms.push(null);
    }
    this._glParamUniforms[0] = gl.getUniformLocation(prog, 'u_p_intensity');
    this._glParamUniforms[1] = gl.getUniformLocation(prog, 'u_p_freq');
    this._glParamUniforms[2] = gl.getUniformLocation(prog, 'u_p_clarity');
    this._glParamUniforms[3] = gl.getUniformLocation(prog, 'u_p_density');

    this._startTime = performance.now() / 1000;
    this._paramValues = new Float32Array(4);

    // Resize
    this._glResize();
    this._resizeObserver = new ResizeObserver(() => this._glResize());
    this._resizeObserver.observe(this);

    // Mouse tracking
    this.addEventListener('mousemove', (e) => {
      const rect = this.getBoundingClientRect();
      this._mouseX = (e.clientX - rect.left) / rect.width;
      this._mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    });

    this._glFrame();
  }

  _glResize() {
    const rect = this.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;
    const dpr = window.devicePixelRatio || 1;
    this._canvas.width = Math.floor(rect.width * dpr);
    this._canvas.height = Math.floor(rect.height * dpr);
    if (this._gl) {
      this._gl.viewport(0, 0, this._canvas.width, this._canvas.height);
    }
  }

  _glFrame() {
    this._animFrame = requestAnimationFrame(() => this._glFrame());
    const gl = this._gl;
    if (!gl || !this._glProgram) return;

    const now = performance.now() / 1000;
    const time = now - this._startTime;
    const mouseX = this._mouseX;
    const mouseY = this._mouseY;

    if (!this._arcTimeline) {
      const ease = {
  linear: t => t,
  expo_in: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  expo_out: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  cubic_in_out: t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2,
  smooth: t => t * t * (3 - 2 * t),
  elastic: t => t === 0 || t === 1 ? t : -Math.pow(2, 10*t - 10) * Math.sin((t*10 - 10.75) * (2*Math.PI/3)),
  bounce: t => { const n=7.5625, d=2.75; if(t<1/d) return n*t*t; if(t<2/d) return n*(t-=1.5/d)*t+0.75; if(t<2.5/d) return n*(t-=2.25/d)*t+0.9375; return n*(t-=2.625/d)*t+0.984375; },
};
      this._arcEase = ease;
      this._arcTimeline = [
        { t: 0, name: 'still', transitions: [{ pi: 0, to: 0.1, anim: false, ease: 'linear', dur: 15 },{ pi: 2, to: 0.1, anim: false, ease: 'linear', dur: 15 },] },
        { t: 15, name: 'fire awakens', transitions: [{ pi: 0, to: 0.8, anim: true, ease: 'expo_out', dur: 10 },] },
        { t: 35, name: 'ice responds', transitions: [{ pi: 2, to: 0.9, anim: true, ease: 'cubic_in_out', dur: 8 },] },
      ];
      this._arcState = new Map();
    }
    for (let mi = 0; mi < this._arcTimeline.length; mi++) {
      const m = this._arcTimeline[mi];
      if (time < m.t) continue;
      for (const tr of m.transitions) {
        const key = `${mi}_${tr.pi}`;
        if (!tr.anim) {
          this._arcBaseOverrides = this._arcBaseOverrides || {};
          this._arcBaseOverrides[tr.pi] = tr.to;
          continue;
        }
        const elapsed = time - m.t;
        const progress = Math.min(elapsed / tr.dur, 1.0);
        if (!this._arcState.has(key)) {
          this._arcState.set(key, this._arcBaseOverrides?.[tr.pi] ?? 0);
        }
        const from = this._arcState.get(key);
        const easeFn = this._arcEase[tr.ease] || this._arcEase.linear;
        const t = easeFn(progress);
        this._arcBaseOverrides = this._arcBaseOverrides || {};
        this._arcBaseOverrides[tr.pi] = from + (tr.to - from) * t;
      }
    }


    this._paramValues[0] = (this._arcBaseOverrides?.[0] ?? 0.5) + audioBass;
    this._paramValues[1] = (this._arcBaseOverrides?.[1] ?? 3) + 0;
    this._paramValues[2] = (this._arcBaseOverrides?.[2] ?? 0.8) + audioTreble;
    this._paramValues[3] = (this._arcBaseOverrides?.[3] ?? 3) + 0;

    gl.useProgram(this._glProgram);

    // System uniforms
    const u = this._glUniforms;
    gl.uniform1f(u.u_time, time);
    gl.uniform1f(u.u_audio_bass, 0);
    gl.uniform1f(u.u_audio_mid, 0);
    gl.uniform1f(u.u_audio_treble, 0);
    gl.uniform1f(u.u_audio_energy, 0);
    gl.uniform1f(u.u_audio_beat, 0);
    gl.uniform2f(u.u_resolution, this._canvas.width, this._canvas.height);
    gl.uniform2f(u.u_mouse, mouseX, mouseY);

    // Dynamic param uniforms
    for (let i = 0; i < 4; i++) {
      if (this._glParamUniforms[i]) {
        gl.uniform1f(this._glParamUniforms[i], this._paramValues[i]);
      }
    }

    // Draw fullscreen quad (triangle strip, 4 vertices)
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
}

customElements.define('game-resonance', GameResonance);
export { GameResonance };
export default GameResonance;
