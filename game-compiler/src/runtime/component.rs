//! Web Component ES module generation — produces a self-contained Custom Element
//! that runs a compiled GAME cinematic using the WebGPU API.

use crate::codegen::{CompileOutput, CompiledParam};
use super::arc::generate_arc_component_js;

/// Generate a self-contained ES module that exports a Custom Element.
pub fn wrap_web_component(output: &CompileOutput, tag_name: &str) -> String {
    let wgsl = output.wgsl.replace('`', "\\`").replace("${", "\\${");
    let glsl_vs = output.glsl_vertex.replace('`', "\\`").replace("${", "\\${");
    let glsl_fs = output.glsl_fragment.replace('`', "\\`").replace("${", "\\${");
    let total_floats = output.uniform_float_count;
    let buffer_size = (total_floats * 4).div_ceil(16) * 16;
    let class_name = tag_to_class_name(tag_name);

    let observed_attrs = generate_observed_attrs(&output.data_fields);
    let prop_accessors = generate_prop_accessors(&output.data_fields);
    let data_init = generate_data_init(&output.data_fields);
    let param_update_inline = generate_component_param_update(
        &output.params,
        &output.data_fields,
    );

    format!(
        r##"// {tag_name}.js — Generated by GAME compiler v0.2.0
// Zero-dependency WebGPU component with WebGL2 fallback.
//   <script type="module" src="./{tag_name}.js"></script>
//   <{tag_name}></{tag_name}>

const SHADER = `{wgsl}`;
const GLSL_VS = `{glsl_vs}`;
const GLSL_FS = `{glsl_fs}`;

class {class_name} extends HTMLElement {{
  static get observedAttributes() {{
    return [{observed_attrs}];
  }}

  constructor() {{
    super();
    this.attachShadow({{ mode: 'open' }});
    this._data = {{ {data_init} }};
    this._device = null;
    this._ctx = null;
    this._pipeline = null;
    this._uniformBuffer = null;
    this._uniformData = null;
    this._bindGroup = null;
    this._animFrame = null;
    this._resizeObserver = null;
    this._startTime = 0;
    this._canvas = null;
    this._format = null;
    this._mouseX = 0.5;
    this._mouseY = 0.5;
    this._paramValues = new Float32Array({param_count});
  }}

{prop_accessors}
  attributeChangedCallback(name, _, newVal) {{
    if (name in this._data) {{
      this._data[name] = parseFloat(newVal) || 0;
    }}
  }}

  connectedCallback() {{
    this._init();
  }}

  disconnectedCallback() {{
    if (this._animFrame) {{
      cancelAnimationFrame(this._animFrame);
      this._animFrame = null;
    }}
    if (this._resizeObserver) {{
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }}
    this._device = null;
    this._pipeline = null;
    this._uniformBuffer = null;
    this._ctx = null;
  }}

  async _init() {{
    this.shadowRoot.innerHTML = `
      <style>
        :host {{ display: block; position: relative; background: #000; overflow: hidden; }}
        canvas {{ display: block; width: 100%; height: 100%; }}
        .fallback {{ display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #444; font: 11px/1 system-ui, sans-serif; text-align: center; }}
      </style>
      <canvas></canvas>
    `;

    this._canvas = this.shadowRoot.querySelector('canvas');

    if (!navigator.gpu) {{
      this._initWebGL2();
      return;
    }}

    const adapter = await navigator.gpu.requestAdapter({{
      powerPreference: 'high-performance',
    }});
    if (!adapter) return;

    this._device = await adapter.requestDevice();
    this._device.lost.then((info) => {{
      console.error('WebGPU device lost:', info.message);
    }});

    this._ctx = this._canvas.getContext('webgpu');
    this._format = navigator.gpu.getPreferredCanvasFormat();

    this._resize();
    this._resizeObserver = new ResizeObserver(() => this._resize());
    this._resizeObserver.observe(this);

    const shaderModule = this._device.createShaderModule({{ code: SHADER }});

    const BUFFER_SIZE = {buffer_size};
    this._uniformBuffer = this._device.createBuffer({{
      size: BUFFER_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    }});

    const bindGroupLayout = this._device.createBindGroupLayout({{
      entries: [{{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {{ type: 'uniform' }},
      }}],
    }});

    this._bindGroup = this._device.createBindGroup({{
      layout: bindGroupLayout,
      entries: [{{ binding: 0, resource: {{ buffer: this._uniformBuffer }} }}],
    }});

    this._pipeline = this._device.createRenderPipeline({{
      layout: this._device.createPipelineLayout({{
        bindGroupLayouts: [bindGroupLayout],
      }}),
      vertex: {{
        module: shaderModule,
        entryPoint: 'vs_main',
      }},
      fragment: {{
        module: shaderModule,
        entryPoint: 'fs_main',
        targets: [{{ format: this._format }}],
      }},
      primitive: {{
        topology: 'triangle-strip',
      }},
    }});

    this._uniformData = new Float32Array(Math.ceil(BUFFER_SIZE / 4));
    this._startTime = performance.now() / 1000;

    // Mouse tracking scoped to this element
    this.addEventListener('mousemove', (e) => {{
      const rect = this.getBoundingClientRect();
      this._mouseX = (e.clientX - rect.left) / rect.width;
      this._mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    }});

    this._frame();
  }}

  _resize() {{
    if (!this._device || !this._ctx || !this._format) return;
    const rect = this.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;
    const dpr = window.devicePixelRatio || 1;
    this._canvas.width = Math.floor(rect.width * dpr);
    this._canvas.height = Math.floor(rect.height * dpr);
    this._ctx.configure({{
      device: this._device,
      format: this._format,
      alphaMode: 'opaque',
    }});
  }}

  _frame() {{
    this._animFrame = requestAnimationFrame(() => this._frame());
    if (!this._device || !this._pipeline || !this._uniformBuffer) return;

    const now = performance.now() / 1000;
    const time = now - this._startTime;
    const mouseX = this._mouseX;
    const mouseY = this._mouseY;

    // Apply arc timeline (override param bases)
{arc_component_update}

    // Update param values
{param_update_inline}

    // Write uniforms
    this._uniformData[0] = time;
    this._uniformData[1] = 0; // audio_bass (unused in component mode)
    this._uniformData[2] = 0; // audio_mid
    this._uniformData[3] = 0; // audio_treble
    this._uniformData[4] = 0; // audio_energy
    this._uniformData[5] = 0; // audio_beat
    this._uniformData[6] = this._canvas.width;
    this._uniformData[7] = this._canvas.height;
    this._uniformData[8] = mouseX;
    this._uniformData[9] = mouseY;

    for (let i = 0; i < {param_count}; i++) {{
      this._uniformData[10 + i] = this._paramValues[i];
    }}

    this._device.queue.writeBuffer(this._uniformBuffer, 0, this._uniformData);

    const encoder = this._device.createCommandEncoder();
    const pass = encoder.beginRenderPass({{
      colorAttachments: [{{
        view: this._ctx.getCurrentTexture().createView(),
        loadOp: 'clear',
        clearValue: {{ r: 0, g: 0, b: 0, a: 1 }},
        storeOp: 'store',
      }}],
    }});
    pass.setPipeline(this._pipeline);
    pass.setBindGroup(0, this._bindGroup);
    pass.draw(4, 1, 0, 0);
    pass.end();
    this._device.queue.submit([encoder.finish()]);
  }}

  // ── WebGL2 Fallback ──────────────────────────────────────
  _initWebGL2() {{
    const gl = this._canvas.getContext('webgl2');
    if (!gl) {{
      this._canvas.style.display = 'none';
      const fb = document.createElement('div');
      fb.className = 'fallback';
      fb.textContent = 'WebGPU and WebGL2 not available';
      this.shadowRoot.appendChild(fb);
      return;
    }}

    this._gl = gl;
    this._glMode = true;

    // Compile shaders
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, GLSL_VS);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {{
      console.error('GLSL vertex error:', gl.getShaderInfoLog(vs));
      return;
    }}

    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, GLSL_FS);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {{
      console.error('GLSL fragment error:', gl.getShaderInfoLog(fs));
      return;
    }}

    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {{
      console.error('GLSL link error:', gl.getProgramInfoLog(prog));
      return;
    }}

    this._glProgram = prog;

    // Cache uniform locations
    this._glUniforms = {{
      u_time: gl.getUniformLocation(prog, 'u_time'),
      u_audio_bass: gl.getUniformLocation(prog, 'u_audio_bass'),
      u_audio_mid: gl.getUniformLocation(prog, 'u_audio_mid'),
      u_audio_treble: gl.getUniformLocation(prog, 'u_audio_treble'),
      u_audio_energy: gl.getUniformLocation(prog, 'u_audio_energy'),
      u_audio_beat: gl.getUniformLocation(prog, 'u_audio_beat'),
      u_resolution: gl.getUniformLocation(prog, 'u_resolution'),
      u_mouse: gl.getUniformLocation(prog, 'u_mouse'),
    }};

    // Cache dynamic param uniform locations
    this._glParamUniforms = [];
    for (let i = 0; i < {param_count}; i++) {{
      const name = 'u_p_' + ['placeholder'][0]; // Will be set per-param below
      this._glParamUniforms.push(null);
    }}
{gl_param_locations}

    this._startTime = performance.now() / 1000;
    this._paramValues = new Float32Array({param_count});

    // Resize
    this._glResize();
    this._resizeObserver = new ResizeObserver(() => this._glResize());
    this._resizeObserver.observe(this);

    // Mouse tracking
    this.addEventListener('mousemove', (e) => {{
      const rect = this.getBoundingClientRect();
      this._mouseX = (e.clientX - rect.left) / rect.width;
      this._mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    }});

    this._glFrame();
  }}

  _glResize() {{
    const rect = this.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;
    const dpr = window.devicePixelRatio || 1;
    this._canvas.width = Math.floor(rect.width * dpr);
    this._canvas.height = Math.floor(rect.height * dpr);
    if (this._gl) {{
      this._gl.viewport(0, 0, this._canvas.width, this._canvas.height);
    }}
  }}

  _glFrame() {{
    this._animFrame = requestAnimationFrame(() => this._glFrame());
    const gl = this._gl;
    if (!gl || !this._glProgram) return;

    const now = performance.now() / 1000;
    const time = now - this._startTime;
    const mouseX = this._mouseX;
    const mouseY = this._mouseY;

{arc_component_update}

{param_update_inline}

    gl.useProgram(this._glProgram);

    // System uniforms
    const u = this._glUniforms;
    gl.uniform1f(u.u_time, time);
    gl.uniform1f(u.u_audio_bass, 0);
    gl.uniform1f(u.u_audio_mid, 0);
    gl.uniform1f(u.u_audio_treble, 0);
    gl.uniform1f(u.u_audio_energy, 0);
    gl.uniform1f(u.u_audio_beat, 0);
    gl.uniform2f(u.u_resolution, this._canvas.width, this._canvas.height);
    gl.uniform2f(u.u_mouse, mouseX, mouseY);

    // Dynamic param uniforms
    for (let i = 0; i < {param_count}; i++) {{
      if (this._glParamUniforms[i]) {{
        gl.uniform1f(this._glParamUniforms[i], this._paramValues[i]);
      }}
    }}

    // Draw fullscreen quad (triangle strip, 4 vertices)
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }}
}}

customElements.define('{tag_name}', {class_name});
export {{ {class_name} }};
export default {class_name};
"##,
        tag_name = tag_name,
        wgsl = wgsl,
        glsl_vs = glsl_vs,
        glsl_fs = glsl_fs,
        class_name = class_name,
        buffer_size = buffer_size,
        param_count = output.params.len(),
        observed_attrs = observed_attrs,
        prop_accessors = prop_accessors,
        data_init = data_init,
        param_update_inline = param_update_inline,
        arc_component_update = generate_arc_component_js(&output.arc_moments),
        gl_param_locations = generate_gl_param_locations(&output.params),
    )
}

/// Convert a kebab-case tag name to PascalCase class name.
/// e.g. "game-loading" → "GameLoading"
fn tag_to_class_name(tag: &str) -> String {
    tag.split('-')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

/// Generate `observedAttributes` array content.
fn generate_observed_attrs(data_fields: &[String]) -> String {
    data_fields
        .iter()
        .map(|f| format!("'{f}'"))
        .collect::<Vec<_>>()
        .join(", ")
}

/// Generate property getter/setter pairs for data fields.
fn generate_prop_accessors(data_fields: &[String]) -> String {
    let mut lines = Vec::new();
    for field in data_fields {
        lines.push(format!(
            "  set {field}(v) {{ this._data.{field} = typeof v === 'number' ? v : parseFloat(v) || 0; }}"
        ));
        lines.push(format!("  get {field}() {{ return this._data.{field}; }}"));
        lines.push(String::new());
    }
    lines.join("\n")
}

/// Generate data field initializers for constructor.
fn generate_data_init(data_fields: &[String]) -> String {
    data_fields
        .iter()
        .map(|f| format!("{f}: 0"))
        .collect::<Vec<_>>()
        .join(", ")
}

/// Generate WebGL2 uniform location lookups for dynamic params.
fn generate_gl_param_locations(params: &[CompiledParam]) -> String {
    if params.is_empty() {
        return String::new();
    }
    let mut lines = Vec::new();
    for (i, p) in params.iter().enumerate() {
        lines.push(format!(
            "    this._glParamUniforms[{i}] = gl.getUniformLocation(prog, 'u_{}');",
            p.uniform_field
        ));
    }
    lines.join("\n")
}

/// Generate inline param update code for web component frame loop.
fn generate_component_param_update(
    params: &[CompiledParam],
    data_fields: &[String],
) -> String {
    if params.is_empty() {
        return String::new();
    }

    let mut lines = Vec::new();

    // Declare data variables from component properties
    for field in data_fields {
        lines.push(format!("    const data_{field} = this._data.{field} || 0;"));
    }

    // Param value computation
    for (i, p) in params.iter().enumerate() {
        let mod_expr = p.mod_js.as_deref().unwrap_or("0");
        // Use arc base override if available, otherwise static base value
        lines.push(format!(
            "    this._paramValues[{i}] = (this._arcBaseOverrides?.[{i}] ?? {}) + {};",
            p.base_value, mod_expr
        ));
    }

    lines.join("\n")
}
