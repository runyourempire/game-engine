//! WGSL → GLSL ES 3.0 transpiler.
//!
//! Translates the well-structured WGSL output from the GAME compiler into
//! GLSL ES 3.0 for WebGL2 fallback. Since we control the WGSL generation,
//! the translation is mechanical and reliable.

/// Transpile GAME-generated WGSL into a GLSL ES 3.0 vertex + fragment shader pair.
///
/// Returns `(vertex_glsl, fragment_glsl)`.
pub fn wgsl_to_glsl(wgsl: &str, param_fields: &[String]) -> (String, String) {
    let vertex = generate_vertex_glsl(param_fields);
    let fragment = generate_fragment_glsl(wgsl, param_fields);
    (vertex, fragment)
}

/// Generate the GLSL vertex shader (fullscreen quad).
fn generate_vertex_glsl(param_fields: &[String]) -> String {
    let mut vs = String::with_capacity(512);
    vs.push_str("#version 300 es\n");
    vs.push_str("precision highp float;\n\n");

    // Uniforms — same layout as WGSL, but flattened
    emit_uniform_block(&mut vs, param_fields);

    vs.push_str("out vec2 v_uv;\n\n");
    vs.push_str("void main() {\n");
    vs.push_str("    vec2 pos[4] = vec2[4](\n");
    vs.push_str("        vec2(-1.0, -1.0),\n");
    vs.push_str("        vec2( 1.0, -1.0),\n");
    vs.push_str("        vec2(-1.0,  1.0),\n");
    vs.push_str("        vec2( 1.0,  1.0)\n");
    vs.push_str("    );\n");
    vs.push_str("    gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);\n");
    vs.push_str("    v_uv = pos[gl_VertexID] * 0.5 + 0.5;\n");
    vs.push_str("}\n");
    vs
}

/// Generate the GLSL fragment shader by transpiling the WGSL fragment.
fn generate_fragment_glsl(wgsl: &str, param_fields: &[String]) -> String {
    let mut fs = String::with_capacity(wgsl.len() + 512);
    fs.push_str("#version 300 es\n");
    fs.push_str("precision highp float;\n\n");

    // Uniforms
    emit_uniform_block(&mut fs, param_fields);

    fs.push_str("in vec2 v_uv;\n");
    fs.push_str("out vec4 fragColor;\n\n");

    // Extract and transpile the built-in functions and fragment shader body
    let body = extract_glsl_body(wgsl);
    fs.push_str(&body);

    fs
}

/// Emit uniform declarations matching the WGSL Uniforms struct.
fn emit_uniform_block(out: &mut String, param_fields: &[String]) {
    out.push_str("uniform float u_time;\n");
    out.push_str("uniform float u_audio_bass;\n");
    out.push_str("uniform float u_audio_mid;\n");
    out.push_str("uniform float u_audio_treble;\n");
    out.push_str("uniform float u_audio_energy;\n");
    out.push_str("uniform float u_audio_beat;\n");
    out.push_str("uniform vec2 u_resolution;\n");
    out.push_str("uniform vec2 u_mouse;\n");
    for field in param_fields {
        out.push_str(&format!("uniform float u_{field};\n"));
    }
    out.push_str("\n");
}

/// Extract and transpile WGSL functions and fragment body to GLSL.
fn extract_glsl_body(wgsl: &str) -> String {
    let mut result = String::with_capacity(wgsl.len());
    let lines: Vec<&str> = wgsl.lines().collect();
    let mut i = 0;
    let mut in_fragment = false;
    let mut in_builtin_functions = false;

    while i < lines.len() {
        let line = lines[i];
        let trimmed = line.trim();

        // Skip header comments, struct definitions, vertex shader
        if trimmed.starts_with("// Generated by")
            || trimmed.starts_with("// https://")
            || trimmed.starts_with("struct Uniforms")
            || trimmed.starts_with("struct VertexOutput")
            || trimmed.starts_with("@group")
            || trimmed.starts_with("@vertex")
        {
            // Skip struct blocks
            if trimmed.starts_with("struct") {
                while i < lines.len() && !lines[i].trim().starts_with('}') {
                    i += 1;
                }
                i += 1; // skip closing brace
                continue;
            }
            // Skip @group/@binding lines
            if trimmed.starts_with("@group") {
                i += 1;
                continue;
            }
            // Skip vertex shader block
            if trimmed.starts_with("@vertex") {
                let mut depth = 0;
                while i < lines.len() {
                    if lines[i].contains('{') {
                        depth += 1;
                    }
                    if lines[i].contains('}') {
                        depth -= 1;
                        if depth == 0 {
                            i += 1;
                            break;
                        }
                    }
                    i += 1;
                }
                continue;
            }
            i += 1;
            continue;
        }

        // Detect built-in function section
        if trimmed.starts_with("// ── Built-in functions") {
            in_builtin_functions = true;
            result.push_str("// ── Built-in functions ──────────────────────────────────\n\n");
            i += 1;
            continue;
        }

        // Detect fragment shader start
        if trimmed.starts_with("@fragment") {
            in_fragment = true;
            i += 1; // skip @fragment line
            continue;
        }

        // Transpile WGSL function declarations (builtins)
        if in_builtin_functions && trimmed.starts_with("fn ") {
            let glsl_fn = transpile_function_decl(trimmed);
            result.push_str(&glsl_fn);
            result.push('\n');
            i += 1;
            in_builtin_functions = true;
            continue;
        }

        // Transpile fragment shader entry
        if in_fragment && trimmed.starts_with("fn fs_main") {
            result.push_str("void main() {\n");
            i += 1;
            continue;
        }

        // Inside fragment or builtin functions — transpile lines
        if in_fragment || in_builtin_functions {
            let glsl_line = transpile_line(line);
            result.push_str(&glsl_line);
            result.push('\n');

            // Track end of fragment
            if in_fragment && trimmed == "}" && get_indent_level(line) == 0 {
                in_fragment = false;
            }
        } else if !trimmed.is_empty() {
            // Pass through comments and blank lines
            if trimmed.starts_with("//") || trimmed.is_empty() {
                result.push_str(line);
                result.push('\n');
            }
        } else {
            result.push('\n');
        }

        i += 1;
    }

    result
}

/// Transpile a WGSL function declaration to GLSL.
/// `fn name(p: vec2f, radius: f32) -> f32 {` → `float name(vec2 p, float radius) {`
fn transpile_function_decl(line: &str) -> String {
    let mut s = line.to_string();

    // Extract return type
    let ret_type = if s.contains("-> f32") {
        "float"
    } else if s.contains("-> vec2f") {
        "vec2"
    } else if s.contains("-> vec3f") {
        "vec3"
    } else if s.contains("-> vec4f") {
        "vec4"
    } else {
        "void"
    };

    // Remove return type annotation
    if let Some(arrow_pos) = s.find("->") {
        let brace_pos = s.rfind('{').unwrap_or(s.len());
        s = format!("{}{}", &s[..arrow_pos].trim_end(), &s[brace_pos..]);
    }

    // Remove 'fn ' prefix, add return type
    s = s.replacen("fn ", &format!("{ret_type} "), 1);

    // Transpile parameter types
    s = transpile_types(&s);

    s
}

/// Transpile a single line of WGSL to GLSL.
fn transpile_line(line: &str) -> String {
    let trimmed = line.trim();

    // Empty lines
    if trimmed.is_empty() {
        return String::new();
    }

    // Comments pass through
    if trimmed.starts_with("//") {
        return line.to_string();
    }

    let indent = get_indent_str(line);
    let mut s = trimmed.to_string();

    // Return statements in fragment → assign to fragColor
    if s.starts_with("return vec4f(") || s.starts_with("return color_result") {
        s = s.replacen("return ", "fragColor = ", 1);
    } else if s.starts_with("return vec4f") {
        s = s.replacen("return ", "fragColor = ", 1);
    }

    // Replace `input.uv` with `v_uv`
    s = s.replace("input.uv", "v_uv");

    // Replace `u.time` → `u_time`, `u.resolution` → `u_resolution`, etc.
    s = s.replace("u.time", "u_time");
    s = s.replace("u.resolution", "u_resolution");
    s = s.replace("u.mouse", "u_mouse");
    s = s.replace("u.audio_bass", "u_audio_bass");
    s = s.replace("u.audio_mid", "u_audio_mid");
    s = s.replace("u.audio_treble", "u_audio_treble");
    s = s.replace("u.audio_energy", "u_audio_energy");
    s = s.replace("u.audio_beat", "u_audio_beat");
    // Dynamic params: `u.p_name` → `u_p_name`
    // We need to handle u.p_ prefix
    while let Some(pos) = s.find("u.p_") {
        s = format!("{}u_p_{}", &s[..pos], &s[pos + 4..]);
    }

    // `let` → appropriate GLSL type
    if s.starts_with("let ") || s.contains(" let ") {
        s = transpile_let_decl(&s);
    }

    // `var` → appropriate GLSL type
    if s.starts_with("var ") || s.contains(" var ") {
        s = transpile_var_decl(&s);
    }

    // Type conversions
    s = transpile_types(&s);

    // `select(a, b, cond)` → GLSL: `cond ? b : a`
    s = transpile_select(&s);

    // `for (var i: i32 = ...)` → `for (int i = ...)`
    s = s.replace("var i: i32", "int i");
    s = s.replace("var j: i32", "int j");
    s = s.replace("var i: f32", "float i");
    s = s.replace("i32(", "int(");

    format!("{indent}{s}")
}

/// Transpile WGSL type names to GLSL.
fn transpile_types(s: &str) -> String {
    let mut out = s.to_string();
    out = out.replace("vec2f(", "vec2(");
    out = out.replace("vec3f(", "vec3(");
    out = out.replace("vec4f(", "vec4(");
    out = out.replace(": vec2f", ": vec2");
    out = out.replace(": vec3f", ": vec3");
    out = out.replace(": vec4f", ": vec4");
    out = out.replace("vec2f ", "vec2 ");
    out = out.replace("vec3f ", "vec3 ");
    out = out.replace("vec4f ", "vec4 ");
    out = out.replace(": f32", ": float");
    out = out.replace("f32(", "float(");
    // GLSL function parameter syntax: `vec2 p` not `p: vec2`
    // This is handled in function declarations, not general lines
    out
}

/// Transpile a `let x = ...;` declaration to GLSL with inferred type.
fn transpile_let_decl(s: &str) -> String {
    let mut out = s.to_string();

    // `let x: type = ...` → `type x = ...`
    // First handle explicit type annotations
    let patterns = [
        ("let ", ": float ", "float "),
        ("let ", ": vec2 ", "vec2 "),
        ("let ", ": vec3 ", "vec3 "),
        ("let ", ": vec4 ", "vec4 "),
        ("let ", ": int ", "int "),
    ];

    for (prefix, type_sep, glsl_type) in patterns {
        if out.contains(type_sep) {
            // Find `let name: type = value`
            if let Some(let_pos) = out.find(prefix) {
                let after_let = &out[let_pos + prefix.len()..];
                if let Some(type_pos) = after_let.find(type_sep) {
                    let name = &after_let[..type_pos];
                    let rest = &after_let[type_pos + type_sep.len()..];
                    out = format!(
                        "{}{glsl_type}{name} = {rest}",
                        &out[..let_pos]
                    );
                    return out;
                }
            }
        }
    }

    // Infer type from RHS
    out = infer_and_replace_let(&out, "let ");
    out
}

/// Transpile a `var x = ...;` declaration to GLSL with inferred type.
fn transpile_var_decl(s: &str) -> String {
    let mut out = s.to_string();

    // Handle explicit type: `var x: type = ...`
    let patterns = [
        ("var ", ": float", "float "),
        ("var ", ": vec2", "vec2 "),
        ("var ", ": vec3", "vec3 "),
        ("var ", ": vec4", "vec4 "),
        ("var ", ": int", "int "),
    ];

    for (prefix, type_sep, glsl_type) in patterns {
        if let Some(var_pos) = out.find(prefix) {
            let after_var = &out[var_pos + prefix.len()..];
            if let Some(type_pos) = after_var.find(type_sep) {
                let name = &after_var[..type_pos];
                let after_type = &after_var[type_pos + type_sep.len()..];
                // Skip past any space after the type name
                let rest = after_type.trim_start();
                if rest.starts_with('=') || rest.starts_with(';') {
                    out = format!(
                        "{}{glsl_type}{name} {rest}",
                        &out[..var_pos]
                    );
                    return out;
                }
            }
        }
    }

    // Infer type from RHS
    out = infer_and_replace_let(&out, "var ");
    out
}

/// Infer GLSL type from the right-hand side and replace `let`/`var` with the type.
fn infer_and_replace_let(s: &str, keyword: &str) -> String {
    if let Some(kw_pos) = s.find(keyword) {
        let after_kw = &s[kw_pos + keyword.len()..];
        if let Some(eq_pos) = after_kw.find('=') {
            let rhs = after_kw[eq_pos + 1..].trim();
            let glsl_type = infer_glsl_type(rhs);
            let name = after_kw[..eq_pos].trim();
            return format!(
                "{}{glsl_type} {name} = {rhs}",
                &s[..kw_pos]
            );
        }
    }
    s.to_string()
}

/// Infer a GLSL type from an expression's pattern.
fn infer_glsl_type(expr: &str) -> &'static str {
    if expr.starts_with("vec4(") || expr.starts_with("vec4f(") {
        "vec4"
    } else if expr.starts_with("vec3(") || expr.starts_with("vec3f(") {
        "vec3"
    } else if expr.starts_with("vec2(") || expr.starts_with("vec2f(") {
        "vec2"
    } else if expr.contains(".rgb")
        || expr.contains("color_result")
        || (expr.starts_with("mix(") && expr.contains("vec3"))
    {
        "vec3"
    } else if expr.starts_with("abs(p)") || expr.contains("* aspect") {
        "vec2"
    } else {
        "float"
    }
}

/// Transpile `select(a, b, cond)` to GLSL.
/// WGSL: `select(false_val, true_val, condition)` → GLSL: `condition ? true_val : false_val`
fn transpile_select(s: &str) -> String {
    let mut out = s.to_string();
    // Simple case: single-level select
    while let Some(pos) = out.find("select(") {
        if let Some(end) = find_matching_paren(&out, pos + 6) {
            let inner = &out[pos + 7..end];
            // Split by top-level commas
            let parts = split_top_level_commas(inner);
            if parts.len() == 3 {
                let false_val = parts[0].trim();
                let true_val = parts[1].trim();
                let condition = parts[2].trim();
                let replacement = format!("({condition} ? {true_val} : {false_val})");
                out = format!("{}{replacement}{}", &out[..pos], &out[end + 1..]);
            } else {
                break; // Can't parse, leave as-is
            }
        } else {
            break;
        }
    }
    out
}

/// Find the matching closing parenthesis.
fn find_matching_paren(s: &str, open_pos: usize) -> Option<usize> {
    let bytes = s.as_bytes();
    let mut depth = 1;
    let mut i = open_pos + 1;
    while i < bytes.len() {
        match bytes[i] {
            b'(' => depth += 1,
            b')' => {
                depth -= 1;
                if depth == 0 {
                    return Some(i);
                }
            }
            _ => {}
        }
        i += 1;
    }
    None
}

/// Split a string by commas at the top level (not inside parentheses).
fn split_top_level_commas(s: &str) -> Vec<&str> {
    let mut parts = Vec::new();
    let mut depth = 0;
    let mut start = 0;
    for (i, c) in s.char_indices() {
        match c {
            '(' | '[' => depth += 1,
            ')' | ']' => depth -= 1,
            ',' if depth == 0 => {
                parts.push(&s[start..i]);
                start = i + 1;
            }
            _ => {}
        }
    }
    parts.push(&s[start..]);
    parts
}

fn get_indent_level(line: &str) -> usize {
    let trimmed_len = line.trim_start().len();
    if trimmed_len == 0 {
        return 0;
    }
    (line.len() - trimmed_len) / 4
}

fn get_indent_str(line: &str) -> String {
    let trimmed = line.trim_start();
    line[..line.len() - trimmed.len()].to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn transpile_simple_wgsl() {
        let wgsl = r#"// Generated by GAME compiler v0.2.0
// https://github.com/runyourempire/game-engine

struct Uniforms {
    time: f32,
    audio_bass: f32,
    audio_mid: f32,
    audio_treble: f32,
    audio_energy: f32,
    audio_beat: f32,
    resolution: vec2f,
    mouse: vec2f,
}

@group(0) @binding(0) var<uniform> u: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(@builtin(vertex_index) vi: u32) -> VertexOutput {
    var pos = array<vec2f, 4>(
        vec2f(-1.0, -1.0),
        vec2f( 1.0, -1.0),
        vec2f(-1.0,  1.0),
        vec2f( 1.0,  1.0),
    );
    var out: VertexOutput;
    out.position = vec4f(pos[vi], 0.0, 1.0);
    out.uv = pos[vi] * 0.5 + 0.5;
    return out;
}

// ── Built-in functions ──────────────────────────────────

fn apply_glow(d: f32, intensity: f32) -> f32 {
    return exp(-max(d, 0.0) * intensity * 8.0);
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4f {
    let uv = input.uv * 2.0 - 1.0;
    let aspect = u.resolution.x / u.resolution.y;
    let time = fract(u.time / 120.0) * 120.0;

    var p = vec2f(uv.x * aspect, uv.y);
    var sdf_result = length(p) - 0.3;
    let glow_result = apply_glow(sdf_result, 2.0);
    return vec4f(vec3f(glow_result), 1.0);
}"#;

        let (vs, fs) = wgsl_to_glsl(wgsl, &[]);

        // Vertex shader checks
        assert!(vs.contains("#version 300 es"), "should have GLSL version");
        assert!(vs.contains("gl_VertexID"), "should use gl_VertexID");
        assert!(vs.contains("v_uv"), "should output v_uv");

        // Fragment shader checks
        assert!(fs.contains("#version 300 es"), "should have GLSL version");
        assert!(fs.contains("out vec4 fragColor"), "should have fragColor output");
        assert!(fs.contains("uniform float u_time"), "should have time uniform");
        assert!(fs.contains("v_uv"), "should reference v_uv not input.uv");
        assert!(fs.contains("u_resolution"), "should reference u_resolution not u.resolution");
        assert!(fs.contains("fragColor ="), "should assign to fragColor");
        assert!(!fs.contains("vec2f("), "should not contain WGSL vec2f");
        assert!(!fs.contains("@fragment"), "should not contain WGSL annotations");
    }

    #[test]
    fn transpile_select() {
        let input = "sdf_result = select(999.0, sdf_result, arc_theta < 3.14);";
        let output = super::transpile_select(input);
        assert!(output.contains("arc_theta < 3.14 ?"), "should transpile select to ternary");
    }
}
