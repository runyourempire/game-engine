//! Documentation generation for `.game` files.
//!
//! Produces a Markdown document describing the structure of a compiled
//! cinematic: layers, parameters, arc timeline, interaction handlers,
//! resonance bindings, defines, and a summary.

use crate::ast::{Cinematic, Expr};
use crate::codegen::CompileOutput;

/// Generate markdown documentation from a parsed cinematic and its compilation output.
pub fn generate_docs(cinematic: &Cinematic, output: &CompileOutput) -> String {
    let mut doc = String::with_capacity(2048);

    // Title
    let title = cinematic.name.as_deref().unwrap_or("Untitled");
    doc.push_str(&format!("# {title}\n\n"));
    doc.push_str("*Generated by GAME compiler v0.2.0*\n\n");

    // Warnings
    if !output.warnings.is_empty() {
        doc.push_str("## Warnings\n\n");
        for w in &output.warnings {
            doc.push_str(&format!("- {w}\n"));
        }
        doc.push('\n');
    }

    // Layers
    if !cinematic.layers.is_empty() {
        doc.push_str("## Layers\n\n");
        for (i, layer) in cinematic.layers.iter().enumerate() {
            let name = layer.name.as_deref().unwrap_or("unnamed");
            doc.push_str(&format!("### Layer {i}: {name}\n\n"));

            if let Some(chain) = &layer.fn_chain {
                let stages: Vec<String> =
                    chain.stages.iter().map(|s| s.name.clone()).collect();
                doc.push_str(&format!(
                    "**Pipeline:** `{}`\n\n",
                    stages.join(" | ")
                ));
            }

            if !layer.params.is_empty() {
                doc.push_str("**Parameters:**\n\n");
                for p in &layer.params {
                    let mod_str = if p.modulation.is_some() {
                        " (modulated)"
                    } else {
                        ""
                    };
                    doc.push_str(&format!(
                        "- `{}`: {}{}\n",
                        p.name,
                        format_expr(&p.base_value),
                        mod_str
                    ));
                }
                doc.push('\n');
            }

            if let Some(blend) = &layer.blend_mode {
                doc.push_str(&format!("**Blend:** {:?}", blend));
                if let Some(opacity) = layer.blend_opacity {
                    doc.push_str(&format!(" (opacity: {opacity})"));
                }
                doc.push_str("\n\n");
            }
        }
    }

    // Defines
    if !cinematic.defines.is_empty() {
        doc.push_str("## Defines\n\n");
        for d in &cinematic.defines {
            let params = if d.params.is_empty() {
                String::new()
            } else {
                format!("({})", d.params.join(", "))
            };
            doc.push_str(&format!("- `{}{params}`\n", d.name));
        }
        doc.push('\n');
    }

    // Arc timeline
    if !output.arc_moments.is_empty() {
        doc.push_str("## Arc Timeline\n\n");
        for m in &output.arc_moments {
            let name = m.name.as_deref().unwrap_or("â€”");
            doc.push_str(&format!(
                "- **{:.1}s** \"{name}\": {} transition(s)\n",
                m.time_seconds,
                m.transitions.len()
            ));
        }
        doc.push('\n');
    }

    // React
    if !output.react_js.is_empty() {
        doc.push_str("## Interaction (React)\n\n");
        doc.push_str("This cinematic includes user interaction handlers.\n\n");
    }

    // Resonance
    if !output.resonance_js.is_empty() {
        doc.push_str("## Resonance\n\n");
        doc.push_str("Cross-layer parameter modulation is active.\n\n");
    }

    // Summary
    doc.push_str("## Summary\n\n");
    doc.push_str(&format!("- **Layers:** {}\n", output.layer_count));
    doc.push_str(&format!("- **Parameters:** {}\n", output.params.len()));
    doc.push_str(&format!("- **Render mode:** {:?}\n", output.render_mode));
    doc.push_str(&format!("- **Audio reactive:** {}\n", output.uses_audio));
    doc.push_str(&format!("- **Mouse interactive:** {}\n", output.uses_mouse));

    doc
}

/// Format an AST expression as a human-readable string for documentation.
fn format_expr(expr: &Expr) -> String {
    match expr {
        Expr::Number(n) => format!("{n}"),
        Expr::String(s) => format!("\"{s}\""),
        Expr::Ident(name) => name.clone(),
        Expr::FieldAccess { object, field } => {
            format!("{}.{}", format_expr(object), field)
        }
        Expr::BinaryOp { left, op, right } => {
            let op_str = match op {
                crate::ast::BinOp::Add => "+",
                crate::ast::BinOp::Sub => "-",
                crate::ast::BinOp::Mul => "*",
                crate::ast::BinOp::Div => "/",
                crate::ast::BinOp::Gt => ">",
                crate::ast::BinOp::Lt => "<",
            };
            format!("{} {} {}", format_expr(left), op_str, format_expr(right))
        }
        Expr::Negate(inner) => format!("-{}", format_expr(inner)),
        Expr::Call(call) => {
            let args: Vec<String> = call
                .args
                .iter()
                .map(|a| match a {
                    crate::ast::Arg::Positional(e) => format_expr(e),
                    crate::ast::Arg::Named { name, value } => {
                        format!("{}: {}", name, format_expr(value))
                    }
                })
                .collect();
            format!("{}({})", call.name, args.join(", "))
        }
        Expr::Array(elements) => {
            let items: Vec<String> = elements.iter().map(format_expr).collect();
            format!("[{}]", items.join(", "))
        }
        Expr::Ternary {
            condition,
            if_true,
            if_false,
        } => {
            format!(
                "{} ? {} : {}",
                format_expr(condition),
                format_expr(if_true),
                format_expr(if_false)
            )
        }
    }
}
