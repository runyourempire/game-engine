// game-loading-ring.js — Generated by GAME compiler v0.2.0
// Zero-dependency WebGPU component. Import and use:
//   <script type="module" src="./game-loading-ring.js"></script>
//   <game-loading-ring></game-loading-ring>

const SHADER = `// Generated by GAME compiler v0.2.0
// https://github.com/your/game-engine

struct Uniforms {
    time: f32,
    audio_bass: f32,
    audio_mid: f32,
    audio_treble: f32,
    audio_energy: f32,
    audio_beat: f32,
    resolution: vec2f,
    mouse: vec2f,
    p_angle: f32,
}

@group(0) @binding(0) var<uniform> u: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) uv: vec2f,
}

@vertex
fn vs_main(@builtin(vertex_index) vi: u32) -> VertexOutput {
    var pos = array<vec2f, 4>(
        vec2f(-1.0, -1.0),
        vec2f( 1.0, -1.0),
        vec2f(-1.0,  1.0),
        vec2f( 1.0,  1.0),
    );
    var out: VertexOutput;
    out.position = vec4f(pos[vi], 0.0, 1.0);
    out.uv = pos[vi] * 0.5 + 0.5;
    return out;
}

// ── Built-in functions ──────────────────────────────────

fn sdf_circle(p: vec2f, radius: f32) -> f32 {
    return length(p) - radius;
}

fn sdf_sphere(p: vec3f, radius: f32) -> f32 {
    return length(p) - radius;
}

fn apply_glow(d: f32, intensity: f32) -> f32 {
    return exp(-max(d, 0.0) * intensity * 8.0);
}

fn hash2(p: vec2f) -> f32 {
    var p3 = fract(vec3f(p.x, p.y, p.x) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn noise2(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(hash2(i), hash2(i + vec2f(1.0, 0.0)), u.x),
        mix(hash2(i + vec2f(0.0, 1.0)), hash2(i + vec2f(1.0, 1.0)), u.x),
        u.y
    ) * 2.0 - 1.0;
}

fn fbm2(p: vec2f, octaves: i32, persistence: f32, lacunarity: f32) -> f32 {
    var value: f32 = 0.0;
    var amplitude: f32 = 1.0;
    var frequency: f32 = 1.0;
    var max_val: f32 = 0.0;
    for (var i: i32 = 0; i < octaves; i++) {
        value += noise2(p * frequency) * amplitude;
        max_val += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return value / max_val;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4f {
    let uv = input.uv * 2.0 - 1.0;
    let aspect = u.resolution.x / u.resolution.y;
    var p = vec2f(uv.x * aspect, uv.y);
    let time = fract(u.time / 120.0) * 120.0;

    let angle = u.p_angle;

    // stage 0: ring(...)
    var sdf_result = abs(length(p) - 0.3) - 0.04;

    // stage 1: mask_arc(...)
    let arc_theta = atan2(p.x, p.y) + 3.14159265359;
    sdf_result = select(999.0, sdf_result, arc_theta < angle);

    // stage 2: glow(...)
    let glow_result = apply_glow(sdf_result, 2.0);

    return vec4f(vec3f(glow_result), 1.0);
}
`;

class GameLoadingRing extends HTMLElement {
  static get observedAttributes() {
    return ['progress'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._data = { progress: 0 };
    this._device = null;
    this._ctx = null;
    this._pipeline = null;
    this._uniformBuffer = null;
    this._uniformData = null;
    this._bindGroup = null;
    this._animFrame = null;
    this._resizeObserver = null;
    this._startTime = 0;
    this._canvas = null;
    this._format = null;
    this._mouseX = 0.5;
    this._mouseY = 0.5;
    this._paramValues = new Float32Array(1);
  }

  set progress(v) { this._data.progress = typeof v === 'number' ? v : parseFloat(v) || 0; }
  get progress() { return this._data.progress; }

  attributeChangedCallback(name, _, newVal) {
    if (name in this._data) {
      this._data[name] = parseFloat(newVal) || 0;
    }
  }

  connectedCallback() {
    this._init();
  }

  disconnectedCallback() {
    if (this._animFrame) {
      cancelAnimationFrame(this._animFrame);
      this._animFrame = null;
    }
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    this._device = null;
    this._pipeline = null;
    this._uniformBuffer = null;
    this._ctx = null;
  }

  async _init() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; position: relative; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
      </style>
      <canvas></canvas>
    `;

    this._canvas = this.shadowRoot.querySelector('canvas');

    if (!navigator.gpu) return;

    const adapter = await navigator.gpu.requestAdapter({
      powerPreference: 'high-performance',
    });
    if (!adapter) return;

    this._device = await adapter.requestDevice();
    this._device.lost.then((info) => {
      console.error('WebGPU device lost:', info.message);
    });

    this._ctx = this._canvas.getContext('webgpu');
    this._format = navigator.gpu.getPreferredCanvasFormat();

    this._resize();
    this._resizeObserver = new ResizeObserver(() => this._resize());
    this._resizeObserver.observe(this);

    const shaderModule = this._device.createShaderModule({ code: SHADER });

    const BUFFER_SIZE = 48;
    this._uniformBuffer = this._device.createBuffer({
      size: BUFFER_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const bindGroupLayout = this._device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: { type: 'uniform' },
      }],
    });

    this._bindGroup = this._device.createBindGroup({
      layout: bindGroupLayout,
      entries: [{ binding: 0, resource: { buffer: this._uniformBuffer } }],
    });

    this._pipeline = this._device.createRenderPipeline({
      layout: this._device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout],
      }),
      vertex: {
        module: shaderModule,
        entryPoint: 'vs_main',
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fs_main',
        targets: [{ format: this._format }],
      },
      primitive: {
        topology: 'triangle-strip',
      },
    });

    this._uniformData = new Float32Array(Math.ceil(BUFFER_SIZE / 4));
    this._startTime = performance.now() / 1000;

    // Mouse tracking scoped to this element
    this.addEventListener('mousemove', (e) => {
      const rect = this.getBoundingClientRect();
      this._mouseX = (e.clientX - rect.left) / rect.width;
      this._mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    });

    this._frame();
  }

  _resize() {
    if (!this._device || !this._ctx || !this._format) return;
    const rect = this.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;
    const dpr = window.devicePixelRatio || 1;
    this._canvas.width = Math.floor(rect.width * dpr);
    this._canvas.height = Math.floor(rect.height * dpr);
    this._ctx.configure({
      device: this._device,
      format: this._format,
      alphaMode: 'opaque',
    });
  }

  _frame() {
    this._animFrame = requestAnimationFrame(() => this._frame());
    if (!this._device || !this._pipeline || !this._uniformBuffer) return;

    const now = performance.now() / 1000;
    const time = now - this._startTime;
    const mouseX = this._mouseX;
    const mouseY = this._mouseY;

    // Update param values
    const data_progress = this._data.progress || 0;
    this._paramValues[0] = 0 + (data_progress * 6.283);

    // Write uniforms
    this._uniformData[0] = time;
    this._uniformData[1] = 0; // audio_bass (unused in component mode)
    this._uniformData[2] = 0; // audio_mid
    this._uniformData[3] = 0; // audio_treble
    this._uniformData[4] = 0; // audio_energy
    this._uniformData[5] = 0; // audio_beat
    this._uniformData[6] = this._canvas.width;
    this._uniformData[7] = this._canvas.height;
    this._uniformData[8] = mouseX;
    this._uniformData[9] = mouseY;

    for (let i = 0; i < 1; i++) {
      this._uniformData[10 + i] = this._paramValues[i];
    }

    this._device.queue.writeBuffer(this._uniformBuffer, 0, this._uniformData);

    const encoder = this._device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
      colorAttachments: [{
        view: this._ctx.getCurrentTexture().createView(),
        loadOp: 'clear',
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        storeOp: 'store',
      }],
    });
    pass.setPipeline(this._pipeline);
    pass.setBindGroup(0, this._bindGroup);
    pass.draw(4, 1, 0, 0);
    pass.end();
    this._device.queue.submit([encoder.finish()]);
  }
}

customElements.define('game-loading-ring', GameLoadingRing);
export { GameLoadingRing };
export default GameLoadingRing;
